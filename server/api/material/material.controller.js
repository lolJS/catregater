/**
 * Using Rails-like standard naming convention for endpoints.
 * GET     /materials              ->  index
 * POST    /materials              ->  create
 * GET     /materials/:id          ->  show
 * PUT     /materials/:id          ->  update
 * DELETE  /materials/:id          ->  destroy
 */

'use strict';

var _ = require('lodash');
var Material = require('./material.model');

// Get list of materials
exports.index = function(req, res) {
  console.log(req.query);
  if (req.query.lastId) {
    Material.find( { _id: { $lt: req.query.lastId } })
    .sort({ _id: -1 })
    .limit( 10 )
    .exec(function (err, materials) {
      if(err) { return handleError(res, err); }
      return res.json(200, materials);
    });
  }
  else {
    Material.find({})
    .sort({ _id: -1 })
    .limit( 15 )
    .exec(function (err, materials) {
      if(err) { return handleError(res, err); }
      return res.json(200, materials);
    });
  }
};

exports.random = function(req, res) {
  var p = 0.08,                                     
      pad = 0,
      d = (1.0 - Math.sqrt(1.0 - p)) * (1.0 + pad);

  if (d > 1.0) d = 1.0;
  if (d < 0.0) d = 0.0;

  var s0 = Math.random() * (1.0 - d),
      s1 = Math.random() * (1.0 - d);

  // Pretty Good Random Sampling from Database Queries
  // http://erikerlandson.github.io/blog/2012/05/16/pretty-good-random-sampling-from-database-queries/
  // (because mongo doesn't have it and selecting the whole db isn't an option to do an _.shuffle().)
  Material.find({ "$or": [ { rk0: { "$gte": s0, "$lt": s0 + d }}, { rk1: { "$gte": s1, "$lt": s1 + d } } ] })
  .sort( { rk0: -1 } )
  .limit( 15 )
  .exec(function (err, materials) {
    if (err) { return handleError(res, err); }
    return res.json(200, _.shuffle(materials));
  })
};

// These functions are not exposed but auto generated by Yeoman.
// Get a single material
exports.show = function(req, res) {
  Material.findById(req.params.id, function (err, material) {
    if(err) { return handleError(res, err); }
    if(!material) { return res.send(404); }
    return res.json(material);
  });
};

// Creates a new material in the DB.
exports.create = function(req, res) {
  Material.create(req.body, function(err, material) {
    if(err) { return handleError(res, err); }
    return res.json(201, material);
  });
};

// Updates an existing material in the DB.
exports.update = function(req, res) {
  if(req.body._id) { delete req.body._id; }
  Material.findById(req.params.id, function (err, material) {
    if (err) { return handleError(res, err); }
    if(!material) { return res.send(404); }

    var updated = _.merge(material, req.body);

    updated.save(function (err) {
      if (err) { return handleError(res, err); }
      return res.json(200, material);
    });
  });
};

// Deletes a material from the DB.
exports.destroy = function(req, res) {
  Material.findById(req.params.id, function (err, material) {
    if(err) { return handleError(res, err); }
    if(!material) { return res.send(404); }

    material.remove(function(err) {
      if(err) { return handleError(res, err); }
      return res.send(204);
    });
  });
};

function handleError(res, err) {
  return res.send(500, err);
}